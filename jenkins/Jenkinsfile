pipeline {
    agent any
    
    environment {
        PYTHON_VERSION = '3'
        VENV_DIR = 'venv'
    }
    
    stages {
        stage('Setup Environment') {
            steps {
                script {
                    // Added closing quote to your echo command
                    sh '''
                        echo "Setting up Python environment"
                        
                        # Install System Dependencies
                        apt-get update && apt-get install -y python3 python3-venv python3-pip wget gnupg unzip curl xvfb libxi6 libgbm1 libnss3 docker.io
                        
                        # Install Chrome
                        mkdir -p /etc/apt/keyrings
                        wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | gpg --dearmor --batch --yes -o /etc/apt/keyrings/google-chrome.gpg
                        echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/google-chrome.gpg] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
                        apt-get update && apt-get install -y google-chrome-stable

                        # Setup Python Virtual Env
                        python${PYTHON_VERSION} -m venv ${VENV_DIR}
                        
                        # Activate and Install Requirements
                        # (Note: We use the direct path to avoid 'source' issues)
                        ${VENV_DIR}/bin/pip install --upgrade pip
                        ${VENV_DIR}/bin/pip install -r requirements.txt
                        
                        echo "Starting application..."
                        # Run in background AND save the PID to a file named 'app.pid'
                        nohup ${VENV_DIR}/bin/python main.py > app.log 2>&1 & echo $! > app.pid
                    '''
                }
            }
        }
        
        
        stage('Lint Code') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && flake8 app/ --output-file=reports/flake8.txt || true'
                    sh '. ${VENV_DIR}/bin/activate && pylint app/ --output=reports/pylint.txt || true'
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/*.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                script {
                    sh 'mkdir -p reports'
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html --junit-xml=reports/unit-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/unit-tests.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Unit Test Coverage Report'
                    ])
                    archiveArtifacts artifacts: 'htmlcov/**/*', allowEmptyArchive: false
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/integration-tests.xml'
                }
            }
        }
        
        stage('End-to-End Tests') {
            steps {
                script {
                    sh '''
                        . ${VENV_DIR}/bin/activate
                        export DISPLAY=:99
                        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
                        sleep 3
                        pytest tests/e2e/ -v --junit-xml=reports/e2e-tests.xml
                        killall Xvfb || true
                    '''
                }
            }
            post {
                always {
                    junit 'reports/e2e-tests.xml'
                }
            }
        }
        
        // stage('Performance Tests') {
        //     steps {
        //         script {
        //             sh '''
        //                 . ${VENV_DIR}/bin/activate
                        
        //                 python app.py &
        //                 APP_PID=$!
        //                 sleep 5
                        
        //                 locust -f tests/performance/locustfile.py \\
        //                     --headless \\
        //                     --users 10 \\
        //                     --spawn-rate 2 \\
        //                     --run-time 30s \\
        //                     --host http://localhost:5000 \\
        //                     --html reports/performance-report.html
                        
        //                 kill $APP_PID || true
        //             '''
        //         }
        //     }
        //     post {
        //         always {
        //             publishHTML([
        //                 allowMissing: false,
        //                 alwaysLinkToLastBuild: true,
        //                 keepAll: true,
        //                 reportDir: 'reports',
        //                 reportFiles: 'performance-report.html',
        //                 reportName: 'Performance Test Report'
        //             ])
        //         }
        //     }
        // }
        
        // stage('Security Scan') {
        //     steps {
        //         script {
        //             sh '. ${VENV_DIR}/bin/activate && bandit -r app/ -f json -o reports/bandit-report.json || true'
        //         }
        //     }
        //     post {
        //         always {
        //             archiveArtifacts artifacts: 'reports/bandit-report.json', allowEmptyArchive: true
        //         }
        //     }
        // }
        
        stage('Build & Push Docker Image') {
            // Run only on main or develop branches
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    echo "Detecting latest version tag..."
                    
                    // 1. Fetch tags to ensure we see them in Jenkins
                    sh 'git fetch --tags'

                    // 2. Logic to calculate version (Taken from your snippet)
                    def latestTag = sh(
                        script: "git tag --sort=-v:refname | grep -Eo 'v[0-9]+\\.[0-9]+\\.[0-9]+' | head -n1 || echo 'v0.0.0'",
                        returnStdout: true
                    ).trim()

                    if (latestTag == '') {
                        latestTag = 'v0.0.0'
                    }
                    
                    echo "Current version: ${latestTag}"
                    
                    def parts = latestTag.replace('v','').tokenize('.')
                    def major = parts[0].toInteger()
                    def minor = parts[1].toInteger()
                    def patch = parts[2].toInteger()

                    // Increment patch version (e.g., v0.0.1 -> v0.0.2)
                    def newVersion = "v${major}.${minor}.${patch + 1}"
                    echo "Building New Version: ${newVersion}"

                    // 3. Login, Build, and Push to Docker Hub
                    withCredentials([usernamePassword(
                        credentialsId: 'docker-hub-creds',
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh """
                            echo "Logging in to Docker Hub..."
                            echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin

                            echo "Building image matan8520/ci-cd-matan:${newVersion}..."
                            cd docker
                            docker build -t matan8520/ci-cd-matan:${newVersion} .

                            # Tag as 'latest' as well
                            docker tag matan8520/ci-cd-matan:${newVersion} matan8520/ci-cd-matan:latest

                            echo "Pushing images..."
                            docker push matan8520/ci-cd-matan:${newVersion}
                            docker push matan8520/ci-cd-matan:latest

                            docker logout
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    sh '''
                        echo "Deploying to staging environment"
                        docker stop staging-app || true
                        docker rm staging-app || true
                        docker run -d --name staging-app -p 5001:5000 devops-testing-app:${BUILD_NUMBER}
                        
                        sleep 5
                        curl -f http://localhost:5001/health || exit 1
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh '''
                echo "Stopping the application..."
                # Check if PID file exists, then kill that specific process
                if [ -f app.pid ]; then
                    kill $(cat app.pid) || true
                    rm app.pid
                fi
                
                # Fallback: Kill any lingering python process matching main.py (Optional safety net)
                pkill -f main.py || true

                echo "Cleaning up files..."
                # Remove the virtual environment
                rm -rf ${VENV_DIR}
                
                # Remove Python cache files
                find . -type d -name "__pycache__" -exec rm -rf {} +
                
                # Remove any downloaded reports or artifacts
                rm -rf reports htmlcov *.xml *.log
            '''
            cleanWs()
        }
        success {
            script {
                sh 'echo "Pipeline completed successfully!"'
                emailext (
                    subject: "✅ Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline completed successfully!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Reports:</strong> Check the artifacts section</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
        failure {
            script {
                sh 'echo "Pipeline failed!"'
                emailext (
                    subject: "❌ Pipeline Failure: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline failed!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Failed Stage:</strong> ${currentBuild.currentResult}</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
    }
}