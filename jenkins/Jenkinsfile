pipeline {
    agent any
    
    environment {
        PYTHON_VERSION = '3'
        VENV_DIR = 'venv'
    }
    
    stages {
        stage('Setup Environment') {
            steps {
                script {
                    // Added closing quote to your echo command
                    sh '''
                        echo "Setting up Python environment"
                        
                        # Install System Dependencies
                        apt-get update && apt-get install -y python3 python3-venv python3-pip wget gnupg unzip curl xvfb libxi6 libgbm1 libnss3 docker.io
                        
                        # Install Chrome
                        mkdir -p /etc/apt/keyrings
                        wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | gpg --dearmor --batch --yes -o /etc/apt/keyrings/google-chrome.gpg
                        echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/google-chrome.gpg] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
                        apt-get update && apt-get install -y google-chrome-stable

                        # Setup Python Virtual Env
                        python${PYTHON_VERSION} -m venv ${VENV_DIR}
                        
                        # Activate and Install Requirements
                        # (Note: We use the direct path to avoid 'source' issues)
                        ${VENV_DIR}/bin/pip install --upgrade pip
                        ${VENV_DIR}/bin/pip install -r requirements.txt
                        
                        echo "Starting application..."
                        # Run in background AND save the PID to a file named 'app.pid'
                        nohup ${VENV_DIR}/bin/python main.py > app.log 2>&1 & echo $! > app.pid
                    '''
                }
            }
        }
        
        
        stage('Lint Code') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && flake8 app/ --output-file=reports/flake8.txt || true'
                    sh '. ${VENV_DIR}/bin/activate && pylint app/ --output=reports/pylint.txt || true'
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/*.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                script {
                    sh 'mkdir -p reports'
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html --junit-xml=reports/unit-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/unit-tests.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Unit Test Coverage Report'
                    ])
                    archiveArtifacts artifacts: 'htmlcov/**/*', allowEmptyArchive: false
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/integration-tests.xml'
                }
            }
        }
        
        stage('End-to-End Tests') {
            steps {
                script {
                    sh '''
                        . ${VENV_DIR}/bin/activate
                        export DISPLAY=:99
                        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
                        sleep 3
                        pytest tests/e2e/ -v --junit-xml=reports/e2e-tests.xml
                        killall Xvfb || true
                    '''
                }
            }
            post {
                always {
                    junit 'reports/e2e-tests.xml'
                }
            }
        }
        
        // stage('Performance Tests') {
        //     steps {
        //         script {
        //             sh '''
        //                 . ${VENV_DIR}/bin/activate
                        
        //                 python app.py &
        //                 APP_PID=$!
        //                 sleep 5
                        
        //                 locust -f tests/performance/locustfile.py \\
        //                     --headless \\
        //                     --users 10 \\
        //                     --spawn-rate 2 \\
        //                     --run-time 30s \\
        //                     --host http://localhost:5000 \\
        //                     --html reports/performance-report.html
                        
        //                 kill $APP_PID || true
        //             '''
        //         }
        //     }
        //     post {
        //         always {
        //             publishHTML([
        //                 allowMissing: false,
        //                 alwaysLinkToLastBuild: true,
        //                 keepAll: true,
        //                 reportDir: 'reports',
        //                 reportFiles: 'performance-report.html',
        //                 reportName: 'Performance Test Report'
        //             ])
        //         }
        //     }
        // }
        
        // stage('Security Scan') {
        //     steps {
        //         script {
        //             sh '. ${VENV_DIR}/bin/activate && bandit -r app/ -f json -o reports/bandit-report.json || true'
        //         }
        //     }
        //     post {
        //         always {
        //             archiveArtifacts artifacts: 'reports/bandit-report.json', allowEmptyArchive: true
        //         }
        //     }
        // }
        
        stage('Build & Push Docker Image') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    // 1. Get credentials for BOTH Docker Hub and GitHub
                    withCredentials([
                        usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS'),
                        usernamePassword(credentialsId: 'github-token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')
                    ]) {
                        
                        // --- A. SETUP GIT ---
                        sh """
                            git config --global user.email "jenkins@ci-cd-pipeline.local"
                            git config --global user.name "Jenkins CI Bot"
                            # Important: Set the remote URL to use the token for authentication
                            git remote set-url origin https://${GIT_USER}:${GIT_TOKEN}@github.com/MatanItzhaki12/Devops-ci-cd-exercise.git
                            git fetch --tags
                        """

                        // --- B. CALCULATE VERSION ---
                        // Get the latest tag from GIT (e.g., v0.0.5)
                        def latestTag = sh(
                            script: "git tag --sort=-v:refname | grep -E '^v?[0-9.]+\$' | head -n1",
                            returnStdout: true
                        ).trim()

                        if (latestTag == "") {
                            latestTag = "v0.0.0"
                        }
                        
                        echo "Latest Git Tag: ${latestTag}"

                        // Logic: v0.0.5 -> v0.0.6
                        def cleanTag = latestTag.replace('v', '')
                        def parts = cleanTag.tokenize('.')
                        def newVersion = "v${parts[0]}.${parts[1]}.${parts[2].toInteger() + 1}"
                        
                        echo "---------------------------------------"
                        echo "   New Release Version: ${newVersion}"
                        echo "---------------------------------------"

                        // --- C. DOCKER BUILD & PUSH ---
                        sh """
                            echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
                            
                            echo "Building ${newVersion}..."
                            docker build -f docker/Dockerfile -t matan8520/ci-cd-matan:${newVersion} .
                            docker tag matan8520/ci-cd-matan:${newVersion} matan8520/ci-cd-matan:latest
                            
                            echo "Pushing Docker images..."
                            docker push matan8520/ci-cd-matan:${newVersion}
                            docker push matan8520/ci-cd-matan:latest
                            
                            docker logout
                        """

                        // --- D. GIT TAG & PUSH ---
                        // This updates GitHub so the next build knows to start from v0.0.7
                        sh """
                            echo "Pushing new tag to GitHub..."
                            git tag -a ${newVersion} -m "Jenkins Build ${BUILD_NUMBER}"
                            git push origin ${newVersion}
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    sh '''
                        echo "Deploying to staging environment"
                        docker stop staging-app || true
                        docker rm staging-app || true
                        docker run -d --name staging-app -p 5001:5000 devops-testing-app:${BUILD_NUMBER}
                        
                        sleep 5
                        curl -f http://localhost:5001/health || exit 1
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh '''
                echo "Stopping the application..."
                # Check if PID file exists, then kill that specific process
                if [ -f app.pid ]; then
                    kill $(cat app.pid) || true
                    rm app.pid
                fi
                
                # Fallback: Kill any lingering python process matching main.py (Optional safety net)
                pkill -f main.py || true

                echo "Cleaning up files..."
                # Remove the virtual environment
                rm -rf ${VENV_DIR}
                
                # Remove Python cache files
                find . -type d -name "__pycache__" -exec rm -rf {} +
                
                # Remove any downloaded reports or artifacts
                rm -rf reports htmlcov *.xml *.log
            '''
            cleanWs()
        }
        success {
            script {
                sh 'echo "Pipeline completed successfully!"'
                emailext (
                    subject: "✅ Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline completed successfully!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Reports:</strong> Check the artifacts section</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
        failure {
            script {
                sh 'echo "Pipeline failed!"'
                emailext (
                    subject: "❌ Pipeline Failure: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline failed!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Failed Stage:</strong> ${currentBuild.currentResult}</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
    }
}
